<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Voice Notes - Animated</title>
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    
    <style>
        :root {
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --bg-color: #1c1c1e;
            --text-color: #f2f2f7;
            --text-secondary-color: #8e8e93;
            --ui-color: #2c2c2e;
            --border-color: #3a3a3c;
            --color-recording: #ff3b30;
            --color-placeholder: #6a6a6e;
            --color-cancel: #5856d6;
            --color-success: #34c759;
            --shadow-color: rgba(0, 0, 0, 0.2);
        }

        body.light-mode {
            --bg-color: #f2f2f7;
            --text-color: #1c1c1e;
            --text-secondary-color: #6a6a6e;
            --ui-color: #ffffff;
            --border-color: #d1d1d6;
            --color-placeholder: #b0b0b5;
            --shadow-color: rgba(0, 0, 0, 0.08);
        }

        /* --- Animation Keyframes --- */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse-record {
            0% { box-shadow: 0 0 0 0 rgba(255, 59, 48, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(255, 59, 48, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 59, 48, 0); }
        }

        @keyframes checkmark-pop {
            0% { transform: scale(0.5); opacity: 0; }
            80% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); }
        }
        
        @keyframes shine-effect {
          0% {
            transform: translate(-100%, 100%) rotate(45deg);
          }
          100% {
            transform: translate(100%, -100%) rotate(45deg);
          }
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            transition: background-color 0.4s, color 0.4s;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        header, .editor-pane, .recording-interface {
            transition: background-color 0.4s, border-color 0.4s;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: var(--ui-color);
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .editor-title {
            font-size: 1.5em;
            font-weight: 600;
            outline: none;
        }

        .header-actions button {
            background: none;
            border: none;
            color: var(--text-secondary-color);
            cursor: pointer;
            font-size: 1.2em;
            padding: 8px;
            border-radius: 8px;
            transition: background-color 0.2s, color 0.2s, transform 0.2s;
        }
        .header-actions button:hover {
            background-color: var(--border-color);
            color: var(--text-color);
            transform: scale(1.1);
        }

        main {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }

        .editor-pane {
            background-color: var(--ui-color);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            padding: 15px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 12px var(--shadow-color);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .editor-pane:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px var(--shadow-color);
        }
        
        /* --- Shine Effect Update --- */
        .editor-pane.shine-effect::after {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          width: 200%;
          height: 200%;
          background: linear-gradient(
            to right,
            rgba(255, 255, 255, 0) 0%,
            rgba(255, 255, 255, 0.15) 50%, /* Made brighter */
            rgba(255, 255, 255, 0) 100%
          );
          animation: shine-effect 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Made slower */
          pointer-events: none;
        }


        .editor-pane-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .editor-pane-header h3 {
            margin: 0;
            color: var(--text-secondary-color);
            font-weight: 500;
        }

        .copy-button {
            background: none;
            border: none;
            color: var(--text-secondary-color);
            cursor: pointer;
            font-size: 1em;
            padding: 5px;
            transition: color 0.3s, transform 0.3s;
        }
        .copy-button:hover { color: var(--text-color); }
        .copy-button.copied {
            transform: scale(1.1);
            color: var(--color-success);
        }

        .editor-content {
            flex-grow: 1;
            outline: none;
            line-height: 1.6;
            min-height: 300px;
            transition: opacity 0.4s;
        }
        .editor-content.is-updating {
            opacity: 0;
        }
        
        #polishedNote p { margin-top: 0; }
        #polishedNote h1, #polishedNote h2 { margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }
        #polishedNote ul, #polishedNote ol { padding-left: 20px; }
        #polishedNote code { background-color: var(--border-color); padding: 2px 5px; border-radius: 4px; }
        #polishedNote blockquote { border-left: 3px solid var(--border-color); padding-left: 10px; color: var(--text-secondary-color); margin-left: 0; }

        .placeholder-active {
            color: var(--color-placeholder);
            font-style: italic;
        }
        #editorTitle.placeholder-active {
            font-weight: 600;
            font-style: normal;
            color: var(--text-secondary-color);
        }


        footer { text-align: center; }

        .recording-interface {
            position: relative;
            background-color: var(--ui-color);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            overflow: hidden;
        }
        
        #dynamicContentWrapper {
            position: relative;
            width: 100%;
            max-width: 350px;
            min-height: 110px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .hidable {
            transition: opacity 0.4s ease, transform 0.4s ease;
            opacity: 1;
            transform: translateY(0);
            position: absolute;
            left: 0;
            right: 0;
            margin: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .hidable.is-hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateY(10px);
        }
        #liveWaveformCanvas { height: 60px; width: 100%; }

        .mic-selector-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            max-width: 350px;
        }

        .mic-select {
            width: 100%;
            background-color: var(--ui-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px;
            font-size: 0.9em;
        }
        .mic-select:focus {
            outline: 2px solid var(--color-recording);
            border-color: var(--color-recording);
        }
        
        .button-wrapper {
            position: relative;
            width: 100%;
            height: 70px;
            margin-top: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #recordButton, #cancelButton {
            position: absolute;
        }

        #recordButton {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            background-color: var(--color-recording);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 2;
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), box-shadow 0.2s, background-color 0.2s;
        }
        #recordButton:hover { transform: scale(1.05); }
        .button-wrapper.is-recording #recordButton:hover {
             transform: translateX(-45px) scale(1.05);
        }

        /* --- Added Style --- */
        #recordButton:disabled {
            cursor: not-allowed;
            background-color: var(--border-color);
            transform: scale(1) !important; /* Prevent hover effect when disabled */
        }
        #recordButton:disabled .record-button-inner i {
            color: var(--text-secondary-color);
        }
        /* --- End Added Style --- */

        .button-wrapper.is-recording #recordButton {
            transform: translateX(-45px);
        }

        #recordButton.recording {
            animation: pulse-record 2s infinite;
        }
        .record-button-inner {
            width: 60px;
            height: 60px;
            background-color: var(--bg-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.4s;
        }
        .record-button-inner i { 
            color: var(--color-recording); 
            font-size: 24px; 
            transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28), border-radius 0.3s ease, color 0.2s;
        }
        #recordButton.recording .record-button-inner i.fa-stop {
            transform: scale(0.7);
            border-radius: 4px;
        }

        #cancelButton {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            background-color: var(--ui-color);
            color: var(--text-secondary-color);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            opacity: 0;
            transform: scale(0.5);
            pointer-events: none;
            transition: background-color 0.2s, color 0.2s, opacity 0.4s ease, transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        .button-wrapper.is-recording #cancelButton {
            opacity: 1;
            transform: translateX(45px) scale(1);
            pointer-events: auto;
        }
        
        #cancelButton:hover {
            background-color: var(--color-cancel);
            color: white;
        }
        
        .progress-indicator {
            width: 100%;
            max-width: 350px;
            position: relative;
            padding: 10px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .progress-steps-container {
            width: 100%;
            display: flex;
            justify-content: space-between;
            position: relative;
            z-index: 2;
        }
        .progress-line-bg {
            position: absolute;
            top: 26px;
            left: 15%;
            right: 15%;
            height: 4px;
            background-color: var(--border-color);
            border-radius: 2px;
            z-index: 1;
        }
        .progress-line-fill {
            height: 100%;
            width: 100%;
            background-color: var(--color-success);
            border-radius: 2px;
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.5s cubic-bezier(0.25, 1, 0.5, 1);
        }
        .progress-step {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
            color: var(--text-secondary-color);
            transition: color 0.4s, transform 0.4s;
        }
        .progress-step.active {
            color: var(--text-color);
            font-weight: 600;
            transform: scale(1.05);
        }
        .progress-step.completed { color: var(--color-success); }
        .dot-container {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--bg-color);
            border-radius: 50%;
            padding: 4px;
        }
        .dot {
            width: 8px;
            height: 8px;
            background-color: var(--border-color);
            border-radius: 50%;
            transition: background-color 0.3s;
        }
        .progress-step.active .dot {
            background-color: var(--color-recording);
            animation: pulse 1.5s infinite ease-in-out;
        }
        .progress-step.completed .dot {
            background-color: var(--color-success);
        }
        .checkmark {
            display: none;
            color: var(--color-success);
        }
        .progress-step.completed .dot { display: none; }
        .progress-step.completed .checkmark {
            display: inline-block;
            animation: checkmark-pop 0.4s ease-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.4); opacity: 0.7; }
        }

        @media (max-width: 992px) {
            main { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

    <div class="container">
        <header>
            <div id="editorTitle" class="editor-title" contenteditable="true" placeholder="Untitled Note"></div>
            <div class="header-actions">
                <button id="newButton" title="New Note"><i class="fa-solid fa-file-circle-plus"></i></button>
                <button id="themeToggleButton" title="Toggle Theme"><i class="fa-solid fa-sun"></i></button>
            </div>
        </header>

        <main>
            <div class="editor-pane">
                <div class="editor-pane-header">
                    <h3>Raw Transcript</h3>
                    <button id="copyRawButton" class="copy-button" title="Copy to Clipboard"><i class="fa-solid fa-copy"></i></button>
                </div>
                <div id="rawTranscription" class="editor-content" contenteditable="true" placeholder="Your raw, unedited transcription will appear here after recording..."></div>
            </div>
            <div class="editor-pane">
                <div class="editor-pane-header">
                    <h3>Cleaned Transcript</h3>
                    <button id="copyCleanedButton" class="copy-button" title="Copy to Clipboard"><i class="fa-solid fa-copy"></i></button>
                </div>
                <div id="cleanedTranscript" class="editor-content" contenteditable="true" placeholder="A cleaned-up version of the transcript will appear here..."></div>
            </div>
            <div class="editor-pane">
                <div class="editor-pane-header">
                    <h3>Polished Note</h3>
                    <button id="copyPolishedButton" class="copy-button" title="Copy to Clipboard (Ctrl+C)"><i class="fa-solid fa-copy"></i></button>
                </div>
                <div id="polishedNote" class="editor-content" contenteditable="true" placeholder="The polished, AI-formatted note will appear here..."></div>
            </div>
        </main>

        <footer>
            <div class="recording-interface">
                <div id="dynamicContentWrapper">
                    <div class="status-indicator hidable" id="recordingStatus">Ready to record (Space Bar)</div>
                    <div class="progress-indicator hidable is-hidden" id="progressIndicator">
                        <div class="progress-line-bg">
                            <div class="progress-line-fill" id="progressLineFill"></div>
                        </div>
                        <div class="progress-steps-container">
                            <div class="progress-step" id="step1"><div class="dot-container"><div class="dot"></div><i class="fa-solid fa-check checkmark"></i></div><span class="label">Transcribing</span></div>
                            <div class="progress-step" id="step2"><div class="dot-container"><div class="dot"></div><i class="fa-solid fa-check checkmark"></i></div><span class="label">Cleaning</span></div>
                            <div class="progress-step" id="step3"><div class="dot-container"><div class="dot"></div><i class="fa-solid fa-check checkmark"></i></div><span class="label">Polishing</span></div>
                        </div>
                    </div>
                    <div class="hidable is-hidden" id="liveDisplayWrapper">
                        <div id="liveRecordingTitle"></div>
                        <canvas id="liveWaveformCanvas"></canvas>
                        <div id="liveRecordingTimerDisplay">00:00.00</div>
                    </div>
                </div>
                
                <div class="mic-selector-wrapper">
                    <i class="fa-solid fa-microphone-lines"></i>
                    <select id="micSelect" class="mic-select" title="Select Microphone"></select>
                </div>

                <div class="button-wrapper">
                    <button id="recordButton" title="Start/Stop Recording (Space Bar)">
                        <div class="record-button-inner"><i class="fa-solid fa-microphone"></i></div>
                    </button>
                    <button id="cancelButton" title="Cancel Recording (Escape)"><i class="fa-solid fa-xmark"></i></button>
                </div>
            </div>
        </footer>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <script type="module">
        import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";
        
        const GEMINI_API_KEY = "AIzaSyAEsfDhje3Huu6ZiKySwBdEsPdjlhdp8Yw"; // PASTE YOUR GEMINI API KEY HERE
        // Using a more powerful model like Gemini 1.5 Pro is recommended for reliable JSON output.
        const MODEL_NAME = "gemini-2.5-pro";

        class VoiceNotesApp {
            constructor() {
                if (!GEMINI_API_KEY) {
                    // A simple, non-blocking notification
                    const warning = document.createElement('div');
                    warning.textContent = 'Please set your Gemini API Key in the script to enable AI features.';
                    warning.style.cssText = 'position: fixed; top: 10px; left: 50%; transform: translateX(-50%); background: #ffc107; color: black; padding: 10px 20px; border-radius: 8px; z-index: 1000; font-weight: bold;';
                    document.body.appendChild(warning);
                }
                
                this.genAI = GEMINI_API_KEY ? new GoogleGenerativeAI(GEMINI_API_KEY) : null;
                this.isRecording = false;
                this.isCancelled = false;
                this.audioChunks = [];
                this.mediaRecorder = null;
                this.stream = null;
                this.audioContext = null;
                this.analyserNode = null;
                this.waveformDataArray = null;
                this.waveformDrawingId = null;
                this.timerIntervalId = null;
                this.recordingStartTime = 0;
                this.maxVolumeDuringRecording = 0;

                this.bindElements();
                this.bindEventListeners();
                this.initTheme();
                this.createNewNote();
            }

            bindElements() {
                // Main UI
                this.recordButton = document.getElementById('recordButton');
                this.cancelButton = document.getElementById('cancelButton');
                this.buttonWrapper = document.querySelector('.button-wrapper');
                this.newButton = document.getElementById('newButton');
                this.themeToggleButton = document.getElementById('themeToggleButton');
                this.themeToggleIcon = this.themeToggleButton.querySelector('i');
                this.micSelect = document.getElementById('micSelect');
                
                // Editor panes
                this.editorTitle = document.getElementById('editorTitle');
                this.rawTranscription = document.getElementById('rawTranscription');
                this.cleanedTranscript = document.getElementById('cleanedTranscript');
                this.polishedNote = document.getElementById('polishedNote');
                this.copyRawButton = document.getElementById('copyRawButton');
                this.copyCleanedButton = document.getElementById('copyCleanedButton');
                this.copyPolishedButton = document.getElementById('copyPolishedButton');

                // Dynamic Displays
                this.recordingStatus = document.getElementById('recordingStatus');
                this.progressIndicator = document.getElementById('progressIndicator');
                this.progressLineFill = document.getElementById('progressLineFill');
                this.liveDisplayWrapper = document.getElementById('liveDisplayWrapper');
                this.liveRecordingTitle = document.getElementById('liveRecordingTitle');
                this.liveWaveformCanvas = document.getElementById('liveWaveformCanvas');
                this.liveWaveformCtx = this.liveWaveformCanvas.getContext('2d');
                this.liveRecordingTimerDisplay = document.getElementById('liveRecordingTimerDisplay');
            }

            bindEventListeners() {
                this.recordButton.addEventListener('click', () => this.toggleRecording());
                this.cancelButton.addEventListener('click', () => this.cancelRecording());
                this.newButton.addEventListener('click', () => this.createNewNote());
                this.themeToggleButton.addEventListener('click', () => this.toggleTheme());
                this.copyRawButton.addEventListener('click', () => this.copyToClipboard('rawTranscription', this.copyRawButton));
                this.copyCleanedButton.addEventListener('click', () => this.copyToClipboard('cleanedTranscript', this.copyCleanedButton));
                this.copyPolishedButton.addEventListener('click', () => this.copyToClipboard('polishedNote', this.copyPolishedButton));
                this.micSelect.addEventListener('change', () => localStorage.setItem('selectedMicId', this.micSelect.value));
                navigator.mediaDevices.addEventListener('devicechange', () => this.populateMicList());
                window.addEventListener('resize', () => this.handleResize());
                
                // --- KEYBOARD SHORTCUTS ---
                document.addEventListener('keydown', (e) => this.handleKeydown(e));
            }
            
            handleKeydown(event) {
                const activeElement = document.activeElement;
                const isEditing = activeElement && activeElement.isContentEditable;

                // Space Bar: Start/Stop recording
                if (event.code === 'Space' && !isEditing) {
                    event.preventDefault();
                    this.toggleRecording();
                }

                // Escape key: Cancel recording
                if (event.key === 'Escape') {
                    if (this.isRecording) {
                        event.preventDefault();
                        this.cancelRecording();
                    }
                }

                // Control + C: Copy polished notes
                if (event.ctrlKey && (event.key === 'c' || event.key === 'C')) {
                    if (activeElement === this.rawTranscription || activeElement === this.cleanedTranscript) {
                        return; 
                    }
                    event.preventDefault();
                    this.copyToClipboard('polishedNote', this.copyPolishedButton);
                }
            }
            
            async init() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    stream.getTracks().forEach(track => track.stop());
                    await this.populateMicList();
                } catch (error) {
                    console.error("Mic permission error on load:", error);
                    this.recordingStatus.textContent = "Mic permission needed. Please allow and reload.";
                    await this.populateMicList();
                }
            }

            async populateMicList() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const audioInputs = devices.filter(device => device.kind === 'audioinput');
                    
                    this.micSelect.innerHTML = '';
                    if (audioInputs.length === 0) {
                        this.micSelect.innerHTML = '<option>No microphones found</option>';
                        return;
                    }

                    const savedMicId = localStorage.getItem('selectedMicId');
                    audioInputs.forEach(device => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.textContent = device.label || `Microphone ${this.micSelect.length + 1}`;
                        this.micSelect.appendChild(option);
                    });
                    
                    if (savedMicId && audioInputs.some(d => d.deviceId === savedMicId)) {
                        this.micSelect.value = savedMicId;
                    }
                } catch (error) {
                    console.error("Error populating mic list:", error);
                    this.micSelect.innerHTML = '<option>Could not access mics</option>';
                }
            }

            handleResize() {
                if (this.isRecording) {
                    requestAnimationFrame(() => this.setupCanvasDimensions());
                }
            }
            
            setupCanvasDimensions() {
                if (!this.liveWaveformCanvas) return;
                const dpr = window.devicePixelRatio || 1;
                const rect = this.liveWaveformCanvas.getBoundingClientRect();
                this.liveWaveformCanvas.width = rect.width * dpr;
                this.liveWaveformCanvas.height = rect.height * dpr;
                this.liveWaveformCtx.scale(dpr, dpr);
            }

            initTheme() {
                const theme = localStorage.getItem('theme');
                if (theme === 'light') {
                    document.body.classList.add('light-mode');
                    this.themeToggleIcon.classList.replace('fa-sun', 'fa-moon');
                }
            }

            toggleTheme() {
                document.body.classList.toggle('light-mode');
                const isLight = document.body.classList.contains('light-mode');
                localStorage.setItem('theme', isLight ? 'light' : 'dark');
                this.themeToggleIcon.classList.replace(isLight ? 'fa-sun' : 'fa-moon', isLight ? 'fa-moon' : 'fa-sun');
            }

            async toggleRecording() {
                this.isRecording ? this.stopRecording() : this.startRecording();
            }
            
            setupAudioVisualizer() {
                if (!this.stream || this.audioContext) return;
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = this.audioContext.createMediaStreamSource(this.stream);
                this.analyserNode = this.audioContext.createAnalyser();
                this.analyserNode.fftSize = 256;
                this.analyserNode.smoothingTimeConstant = 0.6;
                this.waveformDataArray = new Uint8Array(this.analyserNode.frequencyBinCount);
                source.connect(this.analyserNode);
            }

            drawLiveWaveform() {
                if (!this.isRecording) {
                    if (this.waveformDrawingId) cancelAnimationFrame(this.waveformDrawingId);
                    this.waveformDrawingId = null;
                    return;
                }

                this.waveformDrawingId = requestAnimationFrame(() => this.drawLiveWaveform());
                this.analyserNode.getByteFrequencyData(this.waveformDataArray);

                const ctx = this.liveWaveformCtx;
                const { width, height } = this.liveWaveformCanvas.getBoundingClientRect();
                ctx.clearRect(0, 0, width, height);

                const barCount = this.waveformDataArray.length * 0.8;
                const barWidth = width / barCount;
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-recording').trim();
                ctx.lineWidth = barWidth * 0.7;
                ctx.lineCap = 'round';
                
                let currentMaxVolume = 0;
                for (let i = 0; i < barCount; i++) {
                    const barHeight = Math.max((this.waveformDataArray[i] / 255) * height, 2);
                    if (this.waveformDataArray[i] > currentMaxVolume) currentMaxVolume = this.waveformDataArray[i];
                    ctx.beginPath();
                    ctx.moveTo(i * barWidth, height);
                    ctx.lineTo(i * barWidth, height - barHeight);
                    ctx.stroke();
                }
                if (currentMaxVolume > this.maxVolumeDuringRecording) this.maxVolumeDuringRecording = currentMaxVolume;
            }
            
            updateLiveTimer() {
                if (!this.isRecording) return;
                const elapsedMs = Date.now() - this.recordingStartTime;
                const totalSeconds = Math.floor(elapsedMs / 1000);
                const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
                const seconds = String(totalSeconds % 60).padStart(2, '0');
                const hundredths = String(Math.floor((elapsedMs % 1000) / 10)).padStart(2, '0');
                this.liveRecordingTimerDisplay.textContent = `${minutes}:${seconds}.${hundredths}`;
            }

            startLiveDisplay() {
                this.liveDisplayWrapper.classList.remove('is-hidden');
                this.recordingStatus.classList.add('is-hidden');
                this.buttonWrapper.classList.add('is-recording');
                
                this.setupCanvasDimensions();
                this.recordButton.querySelector('i').classList.replace('fa-microphone', 'fa-stop');
                
                const currentTitle = this.editorTitle.textContent.trim();
                const placeholder = this.editorTitle.getAttribute('placeholder');
                this.liveRecordingTitle.textContent = (currentTitle && currentTitle !== placeholder) ? currentTitle : 'New Recording';

                this.setupAudioVisualizer();
                this.drawLiveWaveform();

                this.recordingStartTime = Date.now();
                this.updateLiveTimer();
                this.timerIntervalId = setInterval(() => this.updateLiveTimer(), 50);
            }

            stopLiveDisplay() {
                this.liveDisplayWrapper.classList.add('is-hidden');
                this.recordingStatus.classList.remove('is-hidden');
                this.buttonWrapper.classList.remove('is-recording');
                
                this.recordButton.querySelector('i').classList.replace('fa-stop', 'fa-microphone');
                
                if (this.waveformDrawingId) cancelAnimationFrame(this.waveformDrawingId);
                if (this.timerIntervalId) clearInterval(this.timerIntervalId);
                this.waveformDrawingId = null;
                this.timerIntervalId = null;

                if (this.audioContext && this.audioContext.state !== 'closed') this.audioContext.close();
                this.audioContext = null;
            }

            async startRecording() {
                try {
                    this.audioChunks = [];
                    this.maxVolumeDuringRecording = 0;
                    this.isCancelled = false;
                    
                    const selectedMicId = this.micSelect.value;
                    this.stream = await navigator.mediaDevices.getUserMedia({ audio: { deviceId: selectedMicId ? { exact: selectedMicId } : undefined } });
                    
                    this.mediaRecorder = new MediaRecorder(this.stream);
                    this.mediaRecorder.ondataavailable = e => { if (e.data.size > 0) this.audioChunks.push(e.data) };
                    
                    // --- Modified onstop handler ---
                    this.mediaRecorder.onstop = () => {
                        this.stopLiveDisplay();
                        if (this.stream) this.stream.getTracks().forEach(track => track.stop());

                        if (this.isCancelled) {
                            this.recordButton.disabled = false; // Re-enable on cancel
                            return;
                        }

                        if (this.maxVolumeDuringRecording < 10) {
                            this.recordingStatus.textContent = 'Recording was silent. Check mic.';
                            this.typeEffect(this.rawTranscription, 'Recording appears to be silent. Please check your system microphone settings and ensure your mic is not muted.');
                            this.recordButton.disabled = false; // Re-enable on silent recording
                            return;
                        }

                        if (this.audioChunks.length > 0) {
                            const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                            this.processAudio(audioBlob);
                        } else {
                            this.recordButton.disabled = false; // Re-enable if no audio was captured
                        }
                    };

                    this.mediaRecorder.start();
                    this.isRecording = true;
                    this.recordButton.classList.add('recording');
                    this.recordButton.setAttribute('title', 'Stop Recording (Space Bar)');
                    this.micSelect.disabled = true;
                    this.startLiveDisplay();

                } catch (error) {
                    console.error("Error starting recording:", error);
                    this.recordingStatus.textContent = `Error: ${error.message}`;
                    this.isRecording = false;
                    this.recordButton.classList.remove('recording');
                    this.stopLiveDisplay();
                }
            }

            stopRecording() {
                if (this.mediaRecorder && this.isRecording) {
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                    this.recordButton.classList.remove('recording');
                    this.recordButton.setAttribute('title', 'Start Recording (Space Bar)');
                    this.micSelect.disabled = false;
                    this.recordingStatus.textContent = 'Processing audio...';
                    this.recordButton.disabled = true; // --- Disable button on stop ---
                }
            }

            cancelRecording() {
                if (!this.isRecording) return;
                this.isCancelled = true;
                this.mediaRecorder.stop();
                this.isRecording = false;
                this.recordButton.classList.remove('recording');
                this.recordButton.setAttribute('title', 'Start Recording (Space Bar)');
                this.micSelect.disabled = false;
                this.recordingStatus.textContent = 'Recording cancelled. Ready to record.';
                this.stopLiveDisplay();
            }
            
            async fileToGenerativePart(blob, mimeType) {
                const base64Data = await new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result.split(',')[1]);
                    reader.readAsDataURL(blob);
                });
                return { inlineData: { data: base64Data, mimeType } };
            }

            updateProgress(stage) {
                const isOff = stage === 'off';
                this.progressIndicator.classList.toggle('is-hidden', isOff);
                this.recordingStatus.classList.toggle('is-hidden', !isOff);
                
                let scaleX = 0;
                if (stage === 'processing') scaleX = 0.5;
                if (stage === 'complete') scaleX = 1;
                this.progressLineFill.style.transform = `scaleX(${scaleX})`;
                
                const steps = {
                    step1: { el: document.getElementById('step1'), label: 'Transcribing', past: 'Transcribed' },
                    step2: { el: document.getElementById('step2'), label: 'Cleaning', past: 'Cleaned' },
                    step3: { el: document.getElementById('step3'), label: 'Polishing', past: 'Polished' }
                };

                Object.values(steps).forEach(s => {
                    s.el.classList.remove('active', 'completed');
                    s.el.querySelector('.label').textContent = s.label;
                });

                if (stage === 'transcribing') {
                    steps.step1.el.classList.add('active');
                } else if (stage === 'processing') {
                    steps.step1.el.classList.add('completed');
                    steps.step1.el.querySelector('.label').textContent = steps.step1.past;
                    steps.step2.el.classList.add('active');
                } else if (stage === 'complete') {
                    Object.values(steps).forEach(s => {
                        s.el.classList.remove('active');
                        s.el.classList.add('completed');
                        s.el.querySelector('.label').textContent = s.past;
                    });
                }
            }

            async processAudio(audioBlob) {
                if (!this.genAI) {
                    this.recordingStatus.textContent = 'API Key not set. Cannot process audio.';
                    this.typeEffect(this.rawTranscription, 'Error: Gemini API Key is missing. Please add it to the script to enable AI transcription and processing.');
                    this.recordButton.disabled = false; // Re-enable on early exit
                    return;
                }
                try {
                    this.updateProgress('transcribing');
                    const model = this.genAI.getGenerativeModel({ 
                        model: MODEL_NAME,
                        generationConfig: { responseMimeType: "application/json" }
                    });
                    const audioPart = await this.fileToGenerativePart(audioBlob, audioBlob.type);
                    
                    const prompt = `
                        Analyze the following audio and provide the output in a single JSON object.
                        The JSON object must have three string keys: "rawTranscript", "cleanedTranscript", and "polishedNote".

                        1. "rawTranscript": Transcribe the spoken words in the audio verbatim. If no clear speech is detected, this field should contain the string "[NO SPEECH DETECTED]".
                        2. "cleanedTranscript": Take the raw transcript and clean it up. Remove all filler words (like "um", "uh", "like"), stutters, and false starts. Do not summarize or rephrase the content, only clean it.
                        3. "polishedNote": Take the core information from the transcript and format it into a polished, well-structured note using Markdown. Use headings, bullet points, and bolding where appropriate to make the information clear and easy to read. Correct any grammatical errors and spelling mistakes.

                        Return ONLY the JSON object.
                    `;

                    const result = await model.generateContent([prompt, audioPart]);
                    let responseText = result.response.text();
                    
                    responseText = responseText.replace(/^```json\n/, '').replace(/\n```$/, '');

                    let processedData;
                    try {
                        processedData = JSON.parse(responseText);
                    } catch (e) {
                        console.error("Failed to parse JSON:", responseText);
                        throw new Error("The AI model returned an invalid format.");
                    }


                    if (!processedData.rawTranscript || processedData.rawTranscript.includes('[NO SPEECH DETECTED]')) {
                        throw new Error("No speech was detected in the audio.");
                    }

                    this.updateProgress('processing');
                    await this.typeEffect(this.rawTranscription, processedData.rawTranscript || '');
                    await this.typeEffect(this.cleanedTranscript, processedData.cleanedTranscript || '');
                    
                    this.updateProgress('complete');
                    await this.typeEffect(this.polishedNote, processedData.polishedNote || '', true);
                    this.setNoteTitle(processedData.polishedNote || '');


                    this.recordingStatus.textContent = 'Note processed! Ready to record.';
                    setTimeout(() => this.updateProgress('off'), 2000);

                } catch (error) {
                    console.error("Error processing audio:", error);
                    this.recordingStatus.textContent = "Failed to process note. Please try again.";
                    this.typeEffect(this.rawTranscription, `Could not process the audio. ${error.message} Please try recording again.`);
                    this.updateProgress('off');
                } finally {
                    this.recordButton.disabled = false; // --- Re-enable button after processing ---
                }
            }
            
            setNoteTitle(polishedText) {
                if (!polishedText) return;
                const lines = polishedText.split('\n');
                const h1 = lines.find(line => line.startsWith('# '));
                let title = h1 ? h1.replace('# ', '').trim() : (lines.find(line => line.trim().length > 3) || '').replace(/[\*\_#]/g, '').trim().substring(0, 60);
                if (title) {
                    this.editorTitle.textContent = title;
                    this.editorTitle.classList.remove('placeholder-active');
                }
            }

            copyToClipboard(elementId, buttonElement) {
                const element = document.getElementById(elementId);
                if (!element || element.classList.contains('placeholder-active')) return;
                
                const textToCopy = element.innerText;
                
                navigator.clipboard.writeText(textToCopy).then(() => {
                    const icon = buttonElement.querySelector('i');
                    buttonElement.classList.add('copied');
                    icon.classList.replace('fa-copy', 'fa-check');
                    
                    const originalTitle = buttonElement.title;
                    buttonElement.title = "Copied!";

                    setTimeout(() => {
                        icon.classList.replace('fa-check', 'fa-copy');
                        buttonElement.classList.remove('copied');
                        buttonElement.title = originalTitle;
                    }, 1500);
                }).catch(err => console.error('Failed to copy:', err));
            }

            createNewNote() {
                ['rawTranscription', 'cleanedTranscript', 'polishedNote', 'editorTitle'].forEach(id => {
                    const el = document.getElementById(id);
                    const placeholder = el.getAttribute('placeholder') || '';
                    if (id === 'polishedNote') el.innerHTML = `<p>${placeholder}</p>`;
                    else el.textContent = placeholder;
                    el.classList.add('placeholder-active');
                });
                this.recordingStatus.textContent = 'Ready to record (Space Bar)';
                this.updateProgress('off');
                if (this.isRecording) this.cancelRecording();
            }
            
            async typeEffect(element, text, isMarkdown = false) {
                element.classList.add('is-updating');
                await new Promise(resolve => setTimeout(resolve, 250));
                
                if (isMarkdown) {
                    element.innerHTML = marked.parse(text);
                } else {
                    element.textContent = text;
                }

                element.classList.remove('placeholder-active', 'is-updating');

                const parentPane = element.closest('.editor-pane');
                if (parentPane) {
                    parentPane.classList.add('shine-effect');
                    parentPane.addEventListener('animationend', () => {
                        parentPane.classList.remove('shine-effect');
                    }, { once: true });
                }
            }
        }
        
        function setupPlaceholders() {
             document.querySelectorAll('[contenteditable][placeholder]').forEach(el => {
                const placeholder = el.getAttribute('placeholder');
                const updateState = () => {
                    const isEmpty = el.textContent.trim() === '' || el.textContent.trim() === placeholder;
                    el.classList.toggle('placeholder-active', isEmpty);
                    if (isEmpty && el.id !== 'polishedNote') {
                        el.textContent = placeholder;
                    } else if (isEmpty && el.id === 'polishedNote') {
                        el.innerHTML = `<p>${placeholder}</p>`;
                    }
                };
                updateState();
                el.addEventListener('focus', () => { if (el.classList.contains('placeholder-active')) el.textContent = ''; });
                el.addEventListener('blur', updateState);
            });
        }

        document.addEventListener('DOMContentLoaded', async () => {
            const app = new VoiceNotesApp();
            await app.init();
            setupPlaceholders();
        });
    </script>

</body>
</html>
